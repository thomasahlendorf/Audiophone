<!DOCTYPE html>
<html>

<head>
	<style>
		html,
		body {
			width: 100%;
			height: 100%;
			margin: 0;
			overflow: hidden;
		}
	</style>
</head>

<body>

	<canvas id="canvas" width="100" height="100" style="border:1px solid #000;">
		Your browser does not support the HTML5 canvas tag.
	</canvas>

	<script type="text/javascript">

		//html, body {
		//	height: 100 %;
		//	margin: 0;
		//}
		//canvas {
		//	width: 100 %;
		//	height: 100 %;
		//	display: block;
		//}

		class MyCanvas {

			constructor(canvas) {
				this.canvas = canvas;
				if (!!window.CanvasRenderingContext2D) {
					this.ctx2d = this.canvas.getContext('2d');
					this.resize(1, 1);
					//context.clearRect(0, 0, canvas.width, canvas.height);

					console.log('CONTEXT 2D SUPPORTED');

				} else {
					console.log('CONTEXT 2D NOT SUPPORTED');
				}

			}

			init() {
			}

			resize(w, h) {

				this.canvas.width = w;
				this.canvas.height = h;
				this.width = this.canvas.width;
				this.height = this.canvas.height;
				//this.ctx2d.fillStyle = colorBg;
				//this.ctx2d.fillRect(0, 0, this.width, this.height);
				console.log('Class Context size changed to ' + this.width + ' x ' + this.height);
			}


			getWidth() { return this.width; }
			getHeight() { return this.height; }
			getContext2d() { return this.ctx2d; }

			/*Graphics primitives*/

			drawRect(x, y, w, h, c) {
				this.ctx2d.beginPath();
				this.ctx2d.strokeStyle = c;
				this.ctx2d.moveTo(x, y);
				this.ctx2d.strokeRect(x, y, w, h);
				this.ctx2d.stroke();
			}
			drawLine(x, y, x1, y1, c) {
				this.ctx2d.beginPath();
				this.ctx2d.strokeStyle = c;
				this.ctx2d.moveTo(x, y);
				this.ctx2d.lineTo(x1, y1);
				this.ctx2d.stroke();
			}
			beginLine(x, y, c) {
				this.ctx2d.beginPath();
				this.ctx2d.strokeStyle = c;
				this.ctx2d.moveTo(x, y);
			}
			extendLine(x, y) {
				this.ctx2d.lineTo(x, y);
			}
			endLine() {
				this.ctx2d.stroke();
			}


			drawCircle(x, y, r, c) {
				this.ctx2d.strokeStyle = c;
				this.ctx2d.moveTo(x + r, y);
				this.ctx2d.beginPath();
				this.ctx2d.arc(x, y, r, 0, Math.PI * 2);
				this.ctx2d.stroke();

			}

			fillRect(x, y, w, h, c) {
				this.ctx2d.fillStyle = c;
				this.ctx2d.fillRect(x, y, w, h);
			}

			drawWindow(x, y, w, h, f, b) {
				this.fillRect(x + 1, y + 1, w - 2, h - 2, b);
				this.drawRect(x, y, w, h, f);
			}

			drawImage(img, x, y) {
				this.ctx2d.drawImage(img, x, y);
			}

			dimRect(x, y, w, h, am) {
				let col = 'rgb(' + am + ',' + am + ',' + am + ')';
				this.ctx2d.globalCompositeOperation = "difference";
				this.fillRect(x, y, w, h, col);
				//canvas.fillRect(0,0,width,height,'#00000040');
				this.ctx2d.globalCompositeOperation = "source-over";
			}
		}


		function main() {
			var canvas = document.getElementById('myCanvas');
			var context = null;
			var width = 1;
			var height = 1;
			var tempCanvas = null;

			var amplify = true;
			var autoAmplify = false;
			var ampVal = .5;

			var audioContext = null;
			var audioSource = null;
			var audioAnalyser = null;
			var audioSlowAnalyser = null;
			var audioGain = null;
			var audioFilter = null;
			var audioCompressor = null;

			//var audioAnalyser = null;
			//var audioGain = null;
			//var audioData = null;
			//var volume = null;

			var dataArray = null;
			var dataMemoryArray = null;
			var fftArray = null;
			var fftSlowArray = null;
			var bufferLength = 0;
			var yImpressum = 0;

			var dimAmount = 3;
			const maxDimAmount = 20;
			var fftX, fftY, fftW, fftH;
			var menuX;
			var waveX, waveY, waveW, waveH;
			var polX, polY, polW, polH;
			var resoX, resoY, resoW, resoH;

			var colorBg = "#101010";
			var col = 50;

			var fpos = 0.0;
			var freq = 1000.0;
			var amt = 1.0;

			const fftSize = 2048;
			var myArrayBuffer = null;
			var anotherArray = null;
			var frameCount = 0;
			//var nowBuffering = null;
			var sampleRate = null;

			function map(x, in_min, in_max, out_min, out_max) {
				return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
			}


			function sampleAudioStream() {
				if (audioAnalyser) {
					audioAnalyser.getFloatFrequencyData(fftArray);
					audioSlowAnalyser.getFloatFrequencyData(fftSlowArray);
					//audioAnalyser.getByteTimeDomainData(dataArray);
					audioAnalyser.getFloatTimeDomainData(dataArray);

					if (autoAmplify) {
						for (var i = 0, sum = 0, minm = 0, maxm = 0; i < bufferLength; i++) {
							let v = dataArray[actDataArray][i];
							sum += v;
							if (v < minm)
								minm = v;
							if (v > maxm)
								maxm = v;
						}
						med = sum / (bufferLength);
						amt = maxm - minm;
					} else
						amt = ampVal;
					if (amplify) {
						if (amt > 0.01)
							for (var i = 0; i < bufferLength; i++)
								dataArray[i] = dataArray[i] / amt;
					}
				}
				//const channel=0;
				//nowBuffering = myArrayBuffer.getChannelData(channel);
				//myArrayBuffer.copyFromChannel(anotherArray, 0, 0);
				//
				// for (var i = 0, length = audioData.length, sum = 0; i < length; i++) {
				//     sum += audioData[i];
				// }
				//volume = sum / (length * 256);
			}

			function drawFFT(sx, sy, w, h) {
				var wStep, bStep;
				if (w < 1 || h < 1)
					return;

				canvas.drawWindow(sx, sy, w, h, 'yellow', colorBg);
				//				context.beginPath();
				//				context.fillStyle = colorBg;


				let usedBufLen = bufferLength / 2;
				if (w < usedBufLen) {
					bStep = usedBufLen / w;
					wStep = 1;
				} else {
					bStep = 1;
					wStep = w / usedBufLen;
				}
				//console.log("Step = " + step + " Len = " + bufferLength);

				for (var i = 0, p = 0; p < usedBufLen && i < w; i += wStep, p += bStep) {
					const y = ((h - (fftSlowArray[~~p] / 50) * h) / 4);
					//if (i == 0)
					//context.moveTo(sx + i, y - 2);
					//else
					//context.lineTo(sx + i, y);
					canvas.drawLine(sx + i, y - 2, sx + i, y, 'orange')
				}
			}

			function drawWave(sx, sy, w, h) {
				var wStep, bStep;
				if (w < 1 || h < 1)
					return;

				canvas.drawWindow(sx, sy, w, h, 'yellow', colorBg);
				canvas.drawLine(sx, sy + h / 2, sx + w, sy + h / 2, 'gray');

				if (w < bufferLength) {
					bStep = bufferLength / w;
					wStep = 1;
				} else {
					bStep = 1;
					wStep = w / bufferLength;
				}

				for (var i = 0, p = 0; p < bufferLength && i < w; i += wStep, p += bStep) {
					const y = sy + h / 2 + (dataArray[~~p] * h) / 2;
					if (i == 0)
						canvas.beginLine(sx + i, y - 2, 'orange');
					//beginLine(sx + i, y - 2, 'orange');
					else
						//extendLine(sx + i, y);
						canvas.extendLine(sx + i, y);
				}
				canvas.endLine();
			}

			function drawPolar(sx, sy, w, h) {
				var wStep, bStep;
				if (w < 1 || h < 1)
					return;
				const dim = (w < h ? w : h) / 2 - 30;
				const cx = sx + w / 2;
				const cy = sy + h / 2;
				//frame

				//variant 1
				//context.fillStyle = colorBg;
				//context.fillRect(sx, sy, w, h);

				canvas.dimRect(sx, sy, w, h, maxDimAmount - dimAmount);

				canvas.drawRect(sx, sy, w, h, 'yellow');

				//polarraster
				let step = dim / 20;
				for (var i = 2 * step; i <= dim; i += step)
					canvas.drawCircle(cx, cy, i, 'rgb(40,40,40)');
				canvas.drawCircle(cx, cy, dim / 2, 'white');

				canvas.drawLine(cx, cy, cx, cy + dim, 'rgb(40,40,40)');
				canvas.drawLine(cx, cy, cx, cy - dim, 'rgb(40,40,40)');
				canvas.drawLine(cx, cy, cx + dim, cy, 'rgb(40,40,40)');
				canvas.drawLine(cx, cy, cx - dim, cy, 'rgb(40,40,40)');
				for (var i = 0; i < 2 * Math.PI; i += Math.PI / 50)
					canvas.drawLine(cx + Math.sin(i) * step, cy + Math.cos(i) * step, cx + Math.sin(i) * dim, cy + Math.cos(i) * dim, 'rgb(30,30,30)');
				for (var i = 0; i < 2 * Math.PI; i += Math.PI / 10)
					canvas.drawLine(cx + Math.sin(i) * step, cy + Math.cos(i) * step, cx + Math.sin(i) * dim, cy + Math.cos(i) * dim, 'rgb(40,40,40)');

				//daten


				let bc = 255;
				var color = 'rgb(' + bc / 1 + ',' + bc / 2 + ',' + bc / 3 + ')';

				let minVar = .01;
				let decVar = .1;

				wstep = Math.PI * 2 / bufferLength;
				//wstep = Math.PI * 2 * freq / sampleRate / 5.0;
				for (var w = 0, p = 0; p < bufferLength && w < Math.PI * 2; w += wstep, p++) {
					let v = dataMemoryArray[p];
					v -= decVar;
					if (v < 0) v = 0;

					sc = (dim / 2 + (dataArray[p] * dim / 2));
					const x = cx + Math.sin(w) * sc;
					const y = cy - Math.cos(w) * sc;
					if (p == 0)
						canvas.beginLine(x, y, color);
					else
						canvas.extendLine(x, y);
				}

				canvas.endLine();

			}

			function drawReso(sx, sy, w, h) {
				var wStep, bStep;
				if (w < 1 || h < 1)
					return;

				//frame
				canvas.drawWindow(sx, sy, w, h, 'yellow', colorBg);

				//daten
				for (var i = 0; i < bufferLength; i++) {
					const y = ~~((dataArray[i] * .9) * h);
					const x = ~~((Math.sin(fpos) * .45 + .5) * w);
					fpos += 880.0 * Math.PI / sampleRate;
					if (i == 0)
						canvas.beginLine(sx + x, sy + h / 2 + y, 'orange');
					else
						canvas.extendLine(sx + x, sy + h / 2 + y);
				}
				canvas.endLine();
			}

			function drawInfo(sx, sy, w, h) {
				canvas.drawWindow(sx, sy, w, h, 'yellow', colorBg);
				canvas.ctx2d.font = "20px sans-serif";
				canvas.ctx2d.fillStyle = '#2f4f2f';
				canvas.ctx2d.fillText("~~AUDIOPOLAR~~ (c) 2024 / Thomas Ahlendorf / thomasahlendorf_at_gmail.com", 200, yImpressum);
			}

			function drawMenu(sx, sy, w, h) {
				canvas.drawWindow(sx, sy, w, h, 'yellow', colorBg);
				let yp = 15;
				let ys = 20;
				canvas.ctx2d.font = "12px sans-serif";
				canvas.ctx2d.fillStyle = '#ffffff';
				canvas.ctx2d.fillText("[fFgGhH] Frequenz: " + freq.toFixed(2) + ' Hz', 10, yp); yp += ys;
				canvas.ctx2d.fillText("[V  ] Verstärkung (an/aus): " + (amplify ? "an" : "aus"), 10, yp); yp += ys;
				if (amplify) {
					canvas.ctx2d.fillText("[v  ] Verstärkung (autom.): " + (autoAmplify ? "an" : "aus"), 10, yp); yp += ys;
					if (autoAmplify) {
						canvas.ctx2d.fillText("[aA ] Verstärkung (Wert): " + (1 / ampVal).toFixed(3), 10, yp); yp += ys;
					}
				}
				canvas.ctx2d.fillText("[Nn ] Nachleuchten (+/-): " + dimAmount, 10, yp); yp += ys;

			}

			function draw() {
				sampleAudioStream();

				//				context.strokeStyle = 'hsl(' + col++ + ',100%,30%)';

				drawFFT(fftX, fftY, fftW, fftH);
				drawWave(waveX, waveY, waveW, waveH);
				drawPolar(polX, polY, polW, polH);
				drawReso(resoX, resoY, resoW, resoH);
				drawInfo(infoX, infoY, infoW, infoH);
				drawMenu(menuX, menuY, menuW, menuH);

			};

			function audiostart() {
				//let stream = null;
				if (navigator.mediaDevices) {
					console.log("getUserMedia supported.");
					console.log('get Audio access');

					//MediaDevices.getUserMedia = MediaDevices.getUserMedia || MediaDevices.webkitGetUserMedia;
					try {
						//stream =  navigator.mediaDevices.getUserMedia({ audio : true, video : false });

						navigator.mediaDevices.enumerateDevices()
							.then((devices) => {
								devices.forEach((device) => {
									console.log(`${device.kind}: ${device.label} id = ${device.deviceId}`);
								});
							});
						navigator.mediaDevices.getUserMedia({ audio: { kind: { ideal: 'audiooutput' } }, video: false })
							.then((stream) => {
								//navigator.mediaDevices.getUserMedia({audio:{deviceId:{exact: deviceId}}})
								//.then((stream) => {

								/* use the stream */
								console.log('Audio aktive = ' + stream);

								audioContext = new AudioContext();
								//audioContext = new (window.AudioContext || window.webkitAudioContext)();
								sampleRate = audioContext.sampleRate;
								//myArrayBuffer = audioContext.createBuffer(2, frameCount, audioContext.sampleRate);
								//anotherArray = new Float32Array(frameCount);
								//const source = audioCtx.createMediaElementSource(myMediaElement);

								console.log('Sample Rate = ' + sampleRate);

								//console.log('create MediaStreamSource ');
								audioSource = audioContext.createMediaStreamSource(stream);

								//console.log('create analyzer');
								audioAnalyser = audioContext.createAnalyser();
								audioAnalyser.fftSize = fftSize;
								audioAnalyser.smoothingTimeConstant = 0.0;

								audioSlowAnalyser = audioContext.createAnalyser();
								audioSlowAnalyser.fftSize = fftSize;
								//audioSlowAnalyser.smoothingTimeConstant = 0.0;
								console.log('FFT Size = ' + fftSize);

								bufferLength = audioAnalyser.frequencyBinCount;
								console.log('Buffr Length = ' + bufferLength);

								dataArray = new Float32Array(bufferLength);
								dataMemoryArray = new Float32Array(bufferLength);

								fftArray = new Float32Array(bufferLength);
								fftSlowArray = new Float32Array(bufferLength);
								//dataArray = new Uint8Array(bufferLength);

								audioGain = audioContext.createGain();
								audioGain.gain.value = 1.00;

								audioFilter = audioContext.createBiquadFilter();
								audioFilter.type = "bandpass";
								audioFilter.frequency.setValueAtTime(5000, audioContext.currentTime);
								audioFilter.Q.setValueAtTime(.1, audioContext.currentTime);;

								audioCompressor = audioContext.createDynamicsCompressor();
								audioCompressor.threshold.setValueAtTime(-50, audioContext.currentTime);
								audioCompressor.knee.setValueAtTime(40, audioContext.currentTime);
								audioCompressor.ratio.setValueAtTime(12, audioContext.currentTime);
								audioCompressor.attack.setValueAtTime(0, audioContext.currentTime);
								audioCompressor.release.setValueAtTime(0.25, audioContext.currentTime);

								audioSource.connect(audioGain);
								audioGain.connect(audioCompressor);
								audioCompressor.connect(audioAnalyser);
								audioCompressor.connect(audioSlowAnalyser);

								//audioGain.connect(audioFilter);
								//audioFilter.connect(audioAnalyser);
								//})
							})

					} catch (err) {
						/* handle the error */
						//console.log('Audio Error');
						console.log(`The following gUM error occurred: ${err}`);
						return false;
					}
				} else {
					//console.log('No Audio Devices');
					console.log("getUserMedia not supported on your browser!");
					return false;
				}

				return true;
			};




			function rand(btm, top) {
				return Math.random() * (top - btm) + btm;
			}

			function randColorRgb(btm, top) {
				const r = rand(btm, top);
				const g = rand(btm, top);
				const b = rand(btm, top);
				//const rCol = 'rgb(${r},${g},${b})'
				const rCol = 'rgb(' + r + ',' + g + ',' + b + ')'
				return rCol;
			}

			function redraw(time) {
				requestAnimationFrame(redraw);
				time *= 0.001;  // convert time to seconds

				//var newWidth = canvas.clientWidth;
				//var newHeight = canvas.clientHeight;
				//var aspect = newWidth / newHeight;
				//
				//newWidth = window.innerWidth ;//|| document.documentElement.clientWidth || document.body.clientWidth;
				//newHeight = window.innerHeight;// || document.documentElement.clientHeight || document.body.clientHeight;
				//
				//if (width != newWidth || height != newHeight)
				//{
				//	//resize
				//	canvas.width= newWidth -50;
				//	canvas.height = newHeight -50;
				//	width = canvas.width;
				//	height = canvas.height;
				//	console.log('Context size changed to ' + width + ' x ' + height);
				//}
				//context.fillStyle = "#101010";
				//context.fillRect(0, 0, width - 2, height - 3);
				draw();
			}


			function getKeyCode(event) {
				var Tastencode = event.which || event.keyCode;
				switch (Tastencode) {
				}
			}


			function getKeyUpCode(event) {
				var Tastencode = event.which || event.keyCode;
				switch (Tastencode) {
				}
			}


			function handleKeyDown(e) {
				//var Tastencode = event.which || event.keyCode; //deprecated
				//var Tastencode = e.code;
				switch (e.key) {
					case "a":
						if (ampVal > .00001)
							ampVal /= 2;
						else
							ampVal = .00001;
						break;
					case "A":
						if (ampVal < 128)
							ampVal *= 2;
						else
							ampVal = 8;
						break;
					case "v":
						amplify = !amplify;
						break;
					case "V":
						autoAmplify = !autoAmplify;
						break;
					case "f":
						freq -= 100;
						if (freq < 100)
							freq = 100;
						break;
					case "F":
						freq += 100;
						if (freq > 20000)
							freq = 20000;
						break;
					case "N":
						dimAmount += 1;
						if (dimAmount > maxDimAmount)
							dimAmount = maxDimAmount;
						break;
					case "n":
						dimAmount -= 1;
						if (dimAmount < 0)
							dimAmount = 0;
						break;
				}
			}

			function resizeHandler() {
				//canvas.width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
				//canvas.height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;;

				let canvas_width = window.innerWidth;// || document.documentElement.clientWidth || document.body.clientWidth;
				let canvas_height = window.innerHeight;// || document.documentElement.clientHeight || document.body.clientHeight;;
				//canvas_width = document.body.scrollWidth;
				//canvas_height = document.body.clientHeight;
				canvas.resize(canvas_width, canvas_height);
				tempCanvas.resize(canvas_width, canvas_height);
				width = canvas_width;
				height = canvas_height;
				console.log('Context size changed to ' + width + ' x ' + height);

				//context.fillStyle = colorBg;
				//context.fillRect(0, 0, width, height);
				console.log('Context size changed to ' + width + ' x ' + height);

				xWall1 = 1;
				xWall2 = 200;	//menu
				xWall4 = width - 2;
				xWall3 = ~~((xWall4 - xWall2) / 3) + xWall2;

				yWall1 = 1;
				yWall6 = height - 2;
				yWall5 = height - 30;
				yWall2 = ~~((yWall5 - yWall1) / 3);
				yWall3 = ~~((yWall5 - yWall1) / 3 * 2);
				yWall4 = ~~((yWall5 - yWall1));

				//menuX = xWall2;
				yImpressum = height - 10;

				fftX = xWall2;
				fftY = yWall1;
				fftW = xWall3 - xWall2;
				fftH = yWall2 - yWall1;

				waveX = xWall2;
				waveY = yWall2;
				waveW = xWall3 - xWall2;
				waveH = yWall3 - yWall2;

				resoX = xWall2;
				resoY = yWall3;
				resoW = xWall3 - xWall2;
				resoH = yWall4 - yWall3;

				polX = xWall3;
				polY = yWall1;
				polW = xWall4 - xWall3;
				polH = yWall5;

				menuX = xWall1;
				menuY = yWall1;
				menuW = xWall2 - xWall1;
				menuH = yWall6 - yWall1;

				infoX = xWall2;
				infoY = yWall5;
				infoW = xWall4 - xWall2;
				infoH = yWall6 - yWall5;
				//console.log('fftX= ' + fftX + ' fftY= ' + fftY + ' fftW ' + fftW + ' fftH=' + fftH);
			}

			function initContext() {
				//CONTEXT 2D
				//				if (!!window.CanvasRenderingContext2D) {
				//					context = canvas.getContext('2d');
				//					resizeContext();
				//					//context.clearRect(0, 0, canvas.width, canvas.height);
				//
				//					console.log('CONTEXT 2D SUPPORTED');
				//
				//				} else {
				//					console.log('CONTEXT 2D NOT SUPPORTED');
				//					return false;
				//				}
				//				tempCanvas = document.createElement('canvas');

				// //WebGL
				// var webgl = ['webgl', 'experimental-webgl', 'webkit-3d', 'moz-webgl'];
				//
				// for (var i = 0, length = webgl.length; i < length; i++) {
				//     try {
				//         context = canvas.getContext(webgl[i]);
				//         break;
				//     } catch(e) {}
				// }

				//if (context) {
				//	console.log('WEBGL SUPPORTED');
				//} else {
				//	console.log('WEBGL NOT SUPPORTED');
				//}

				//const observer = new ResizeObserver((entries) => {
				//	canvas.width = canvas.clientWidth;
				//	canvas.height = canvas.clientHeight;
				//	width = canvas.width;
				//	height = canvas.height;
				//	console.log('Context size changed to ' + width + ' x ' + height);
				//});

				//const observer = new ResizeObserver();
				//observer.observe(canvas)

				cv = document.getElementById('canvas');
				canvas = new MyCanvas(cv);
				cv = document.getElementById('canvas');
				tempCanvas = new MyCanvas(cv);

				window.addEventListener('resize', resizeHandler);

				return true;
			}

			function init() {
				if (!initContext())
					return false;
				if (!audiostart())
					return false;
				return true;
			}

			if (!init())
				return false;

			//"Main"-Area
			//deprecated
			//document.onkeydown = getKeyCode;
			//document.onkeyup = getKeyUpCode;
			//document.onkeypress = getKeyPressCode;

			//const input = document.querySelector("input");
			//input.addEventListener("keydown", handleKeyDown);
			//requestAnimationFrame(redraw);//first time
			document.onkeydown = handleKeyDown;

			resizeHandler();
			redraw();//first time
		}

		main();
	</script>

</body>

</html>